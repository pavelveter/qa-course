import csv  # подключаем модуль для работы с CSV-файлами
import logging  # подключаем модуль для логирования сообщений
from pathlib import Path  # импортируем Path для удобной работы с путями к файлам


# Настраиваем систему логирования: выводить только уровень INFO и выше,
# а формат строк логов будет, например: "INFO Проверено 10 строк"
logging.basicConfig(level=logging.INFO, format="%(levelname)s %(message)s")

# Создаём именованный логгер (чтобы в будущем можно было управлять отдельными частями логов)
log = logging.getLogger("csv-check")

# Определяем допустимые значения приоритета, которые считаются корректными
ALLOWED_PRIORITIES = {"P1", "P2", "P3"}

# Переменные-счётчики: всего строк и сколько из них содержат ошибки
total = bad = 0
# Открываем CSV-файл с именем data.csv для чтения
# encoding="utf-8" — чтобы корректно читать русские буквы
# newline="" — чтобы не добавлялись лишние пустые строки при чтении
with Path("data.csv").open("r", encoding="utf-8", newline="") as f:
    # Создаём объект DictReader, который читает CSV и возвращает строки в виде словарей
    # delimiter=";" — указываем, что разделитель полей — точка с запятой
    reader = csv.DictReader(f, delimiter=";")

    # enumerate даёт нам сразу и номер строки (начиная с 1), и саму строку в виде словаря
    for i, row in enumerate(reader, start=1):
        total += 1  # увеличиваем счётчик обработанных строк
        errors = []  # создаём список ошибок для текущей строки

        # Проверка: если поле title пустое, добавляем описание ошибки
        if not row["title"]:
            errors.append("title пустой")

        # Проверка: если priority не входит в список допустимых значений — это ошибка
        if row["priority"] not in ALLOWED_PRIORITIES:
            errors.append("priority неверный")

        # Если список ошибок не пуст — значит, есть проблема в этой строке
        if errors:
            bad += 1  # увеличиваем количество строк с ошибками
            # Собираем все найденные ошибки в одну строку через запятую
            # и выводим предупреждение (WARNING) с номером строки
            log.warning(f"Строка {i}: {', '.join(errors)}")

# После завершения цикла вычисляем процент ошибок
# (если total == 0, то деление не происходит, чтобы не было ZeroDivisionError)
rate = (bad / total * 100) if total else 0

# Выводим итоговую информацию в лог с уровнем INFO:
# сколько строк проверено, сколько ошибок, и какой процент
log.info(f"Проверено {total}, ошибок {bad} ({rate:.1f}%)")
